/*
 * Copyright 2023 Oxide Computer Company
 */

use std::collections::HashSet;
use std::fs;
use std::io::{ErrorKind, Read};
use std::path::{Path, PathBuf};

use tokio::sync::mpsc;

#[derive(Debug)]
pub enum Activity {
    Error(String),
    Warning(String),
    Scanned(usize),
    Uploading(PathBuf, u64),
    Uploaded(PathBuf),
    Complete,
}

struct Uploader {
    cw: super::ClientWrap,
    tx: mpsc::Sender<Activity>,
    rules: Vec<super::WorkerPingOutputRule>,
}

impl Uploader {
    async fn quota_check(&self, path: &Path, size: u64) -> bool {
        let max_bytes_per_output = self.cw.quota().await.max_bytes_per_output;

        if size <= max_bytes_per_output {
            true
        } else {
            self.tx
                .send(Activity::Error(format!(
                    "file {path:?} is {size} bytes in size, which is larger \
                than the maximum output size of {max_bytes_per_output} \
                bytes and cannot be uploaded at this time."
                )))
                .await
                .unwrap();
            false
        }
    }
}

struct Upload {
    path: PathBuf,
    size: u64,
}

pub(crate) fn upload(
    cw: super::ClientWrap,
    rules: Vec<super::WorkerPingOutputRule>,
) -> mpsc::Receiver<Activity> {
    let (tx, rx) = mpsc::channel::<Activity>(64);

    let upl = Uploader { cw, tx, rules };

    tokio::spawn(async move {
        let mut seen = HashSet::new();
        let mut uploads = Vec::new();

        /*
         * Preprocess the rule list to locate any special handling directives
         * like ignore rules or required matches.
         */
        let mut walk_patterns = Vec::new();
        let mut ignore = Vec::new();
        let mut required = Vec::new();
        let mut relaxed = Vec::new();
        for r in upl.rules.iter() {
            let pat = match glob::Pattern::new(&r.rule) {
                Ok(pat) => pat,
                Err(e) => {
                    upl.tx
                        .send(Activity::Error(format!(
                            "glob {:?} error: {:?}",
                            r.rule, e,
                        )))
                        .await
                        .unwrap();
                    continue;
                }
            };

            if r.ignore {
                /*
                 * The user wants to prevent the upload of any file that matches
                 * this glob pattern.  This rule type is mutually exclusive with
                 * all other special directives, and with regular processing.
                 */
                ignore.push(pat);
                continue;
            }

            if r.require_match {
                /*
                 * The user wants to make sure that this pattern matches at
                 * least one uploaded file.  If no file matches, we want to fail
                 * the job.
                 */
                required.push((pat.clone(), false));
            }

            if r.size_change_ok {
                /*
                 * By default, we will fail an upload if the file changes size
                 * while we are trying to upload it.  This is to avoid
                 * accidentally creating a job which terminates while background
                 * processes are still manipulating output artefacts; such
                 * background manipulation will likely lead to incomplete
                 * or otherwise corrupt artefacts and should result in a job
                 * failure.
                 *
                 * In some cases, the user actually doesn't care that
                 * modification may continue after the job has nominally
                 * completed; e.g., if the job is an integration test and the
                 * file to upload is an informational log generated by a process
                 * that may not have been completely torn down at the end of the
                 * job.  We will still warn about the condition, but not fail
                 * the job or the file upload.
                 */
                relaxed.push(pat.clone());
            }

            walk_patterns.push(r.rule.to_string());
        }

        /*
         * Enumerate all of the files we expect to upload.
         */
        for r in upl.rules.iter().filter(|r| !r.ignore) {
            /*
             * Walk the file system and locate output files to
             * upload.
             */
            match glob::glob(r.rule.as_str()) {
                Ok(paths) => {
                    for p in paths {
                        match p {
                            Ok(p) => {
                                if seen.contains(&p) {
                                    continue;
                                }
                                seen.insert(p.clone());

                                if ignore.iter().any(|g| g.matches_path(&p)) {
                                    /*
                                     * This path matches an ignore rule.  We do
                                     * not want to upload it, even if it matches
                                     * other rules.
                                     */
                                    continue;
                                }

                                match fs::metadata(&p) {
                                    Ok(md) => {
                                        if !md.is_file() {
                                            continue;
                                        }

                                        uploads.push(Upload {
                                            path: p,
                                            size: md.len(),
                                        });
                                    }
                                    Err(e) => {
                                        upl.tx
                                            .send(Activity::Error(format!(
                                                "glob {:?} stat error: {:?}",
                                                r, e
                                            )))
                                            .await
                                            .unwrap();
                                        continue;
                                    }
                                }
                            }
                            Err(e) => {
                                upl.tx
                                    .send(Activity::Error(format!(
                                        "glob {:?} path error: {:?}",
                                        r, e
                                    )))
                                    .await
                                    .unwrap();
                                break;
                            }
                        }
                    }
                }
                Err(e) => {
                    upl.tx
                        .send(Activity::Error(format!(
                            "glob {:?} error: {:?}",
                            r, e
                        )))
                        .await
                        .unwrap();
                }
            }
        }

        upl.tx.send(Activity::Scanned(uploads.len())).await.unwrap();

        /*
         * Upload each scanned file.
         */
        'outer: for u in uploads.iter() {
            upl.tx
                .send(Activity::Uploading(u.path.clone(), u.size))
                .await
                .unwrap();

            if !upl.quota_check(&u.path, u.size).await {
                continue;
            }

            /*
             * Determine whether we care about the file changing size during
             * upload.
             */
            let change_ok = relaxed.iter().any(|g| g.matches_path(&u.path));

            let mut f = match fs::File::open(&u.path) {
                Ok(f) => f,
                Err(e) => {
                    if change_ok && e.kind() == ErrorKind::NotFound {
                        /*
                         * If this file is marked as being a potentially
                         * fluctuating log file, we'll allow it to be completely
                         * absent without raising a fatal error. It may have
                         * been removed by some background process between when
                         * we scanned the file system and when we went to upload
                         * it.
                         */
                        let msg = format!(
                            "file {:?} disappeared between scan and upload",
                            u.path,
                        );
                        upl.tx.send(Activity::Warning(msg)).await.unwrap();
                        continue;
                    }

                    upl.tx
                        .send(Activity::Error(format!(
                            "open {:?} failed: {:?}",
                            u.path, e
                        )))
                        .await
                        .unwrap();
                    continue;
                }
            };

            /*
             * Read 5MB chunks of the file and upload them to the server.
             */
            let mut total = 0;
            let mut chunks = Vec::new();
            loop {
                let mut buf = bytes::BytesMut::new();
                buf.resize(5 * 1024 * 1024, 0);

                let buf = match f.read(&mut buf) {
                    Ok(0) => break,
                    Ok(sz) => {
                        buf.truncate(sz);
                        total += sz as u64;
                        buf.freeze()
                    }
                    Err(e) => {
                        upl.tx
                            .send(Activity::Error(format!(
                                "read {:?} failed: {:?}",
                                u.path, e
                            )))
                            .await
                            .unwrap();
                        continue 'outer;
                    }
                };

                chunks.push(upl.cw.chunk(buf).await);
            }

            if total != u.size {
                let msg = format!(
                    "file {:?} changed size mid upload: {} -> {}",
                    u.path, u.size, total
                );

                if change_ok {
                    upl.tx.send(Activity::Warning(msg)).await.unwrap();
                } else {
                    upl.tx.send(Activity::Error(msg)).await.unwrap();
                    continue;
                }

                /*
                 * If the sized has changed, we need to do another quota check
                 * here so that we can report a useful error.
                 */
                if !upl.quota_check(&u.path, total).await {
                    continue;
                }
            }

            if let Some(e) =
                upl.cw.output(&u.path, total, chunks.as_slice()).await
            {
                upl.tx.send(Activity::Error(e)).await.unwrap();
                continue;
            }

            upl.tx.send(Activity::Uploaded(u.path.clone())).await.unwrap();

            /*
             * Mark as used any rule that requires a match and which matches
             * the path of the file we just uploaded.
             */
            required.iter_mut().for_each(|(g, used)| {
                if g.matches_path(&u.path) {
                    *used = true;
                }
            });
        }

        /*
         * Make sure all rules which required at least one match were satisfied:
         */
        for (g, used) in required.iter() {
            if !used {
                upl.tx
                    .send(Activity::Error(format!(
                        "rule \"{}\" required a match, but was not used",
                        g,
                    )))
                    .await
                    .unwrap();
            }
        }

        upl.tx.send(Activity::Complete).await.unwrap();
    });

    rx
}
